
# linux 内核中的锁


  临界区 | CPU | 内存 | cache
---------|----------|---------|---------
 semaphore | atomic | RCU | Per-CPU
 mutex | spinlock | memory barrier
 rw-lock |  | |
perrmpt抢占 | 


一、atomic原子变量/spinlock自旋锁 — —CPU

既然是锁CPU，那就都是针对多核处理器或多CPU处理器。单核的话，只有发生中断会使任务被抢占，那么可以进入临界区之前先关中断，但是对多核CPU光关中断就不够了，因为对当前CPU关了中断只能使得当前CPU不会运行其它要进入临界区的程序，但其它CPU还是可能执行进入临界区的程序。

### 原子变量：
在x86多核环境下，多核竞争数据总线的时候，提供Lock指令锁住总线，保证“读-修改-写”操作在芯片级的原子性。这个好说，我们一般对某个被多线程会访问的变量设置为atomic类型的即可，比如`atomic_int x；或atomic<int> x`

### 自旋锁：
当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取。使用实例如下：


```c++
#include <linux/spinlock.h>
// 定义自旋锁
spinlock_t my_lock;

void my_function(void)
{
    spin_lock(&my_lock);
    // 访问共享资源的操作
    spin_unlock(&my_lock);
}
```
互斥锁中，要是当前线程没拿到锁，就会出让CPU；而自旋锁中，要是当前线程没有拿到锁，当前线程在CPU上忙等待直到锁可用，这是为了保证响应速度更快。但是这种线程多了，那意味着多个CPU核都在忙等待，使得系统性能下降。
因此一定不能自旋太久，所以用户态编程里用自旋锁保护临界区的话，这个临界区一定要尽可能小，锁的粒度得尽可能小。

### 信号量：
信号量（信号灯）本质是一个计数器，是描述临界区中可用资源数目的计数器。
信号量为3，表示可用资源为3。加入初始信号量为3，某时刻信号量为1，说明可用资源数为1，那么有2个进程/线程在使用资源或者说有两个资源被消耗了（具体资源是什么得看具体情况）。进程对信号量有PV操作，P操作就是进入共享资源区前-1，V操作就是离开共享资源后+1（这个时候信号量就表明还可以允许多少个进程进入该临界区）。
信号量进行多线程通信编程的时候，往往初始化信号量为0，然后用两个函数做线程间同步：
sem_wait()：等待信号量，如果信号量的值大于0,将信号量的值减1,立即返回。如果信号量的值为0,则线程阻塞。
sem_post()：释放资源，信号量+1 ，相当于unlock，这样执行了sem_wait()的线程就不阻塞了。
要注意：信号量本身也是个共享资源，它的++操作（释放资源）和--操作（获取资源）也需要保护。其实就是用的自旋锁保护的。如果有中断的话，会把中断保存到eflags寄存器，待操作完成，就去该寄存器上读取，然后执行中断。
```
struct semaphore {
     spinlock_t lock; // 自旋锁
     unsigned int count;
     struct list_head wait_list;
};
```

### 互斥锁：
```
信号量的话表示可用资源的数量，是允许多个进程/线程在临界区的。但是互斥锁不是，它的目的就是只让一个线程进入临界区，其余线程没拿到锁，就只能阻塞等待。线程互斥的进入临界区，这就是互斥锁名字由来。
```
另外提一下std::timed_mutex睡眠锁，它和互斥锁的区别是：
互斥锁中，没拿到锁的线程就一直阻塞等待，而睡眠锁则是设置一定的睡眠时间比如2s，线程睡眠2s，如果过了之后还没拿到锁，那就放弃拿锁（可以输出获取锁失败），如果拿到了，那就继续做事。比如 用成员函数try_lock_for()

### 读写锁：
用于读操作比写操作更频繁的场景，让读和写分开加锁，这样可以减小锁的粒度，提高程序的性能。
它允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这可以提高并发性能，因为读操作通常比写操作频繁得多。读写锁这种就属于高阶锁了，它的实现就可以用自旋锁。


### 抢占：
抢占必须涉及进程上下文的切换，而中断则是涉及中断上下文的切换。
内核从2.6开始就支持内核抢占，之前的内核不支持抢占，只要进程在占用CPU且时间片没用完，除非有中断，否则它就能一直占用CPU；
抢占的情况：
比如某个优先级高的任务（进程），因为需要等待资源，就主动让出CPU（又或者因为中断被打断了），然后低优先级的任务先占用CPU，当资源到了，内核就让该优先级高的任务抢占那个正在CPU上跑的任务。也就是说，当前的优先级低的进程跑着跑着，时间片没用完，也没发生中断，但是自己被踢掉了。
为了支持内核抢占，内核引入了preempt_count字段，该计数初始值为0，每当使用锁时+1，释放锁时-1。当preempt_count为0时，表示内核可以安全的抢占，大于0时，则禁止内核抢占

### Per-CPU— —作用于cache
per-cpu变量用于解决各个CPU里L2 cache和内存间的数据不一致性。

### RCU机制是read copy update，即读 复制 更新。

和读写锁一样，RCU机制也是允许多个读者同时读，但更新数据的时候，需要先复制一份副本，在副本上完成修改，然后再一次性地替换旧数据。

### 内存屏障：

内存屏障则是用于控制内存访问顺序，确保指令的执行顺序符合预期。
因为代码往往不是看我们写的这种顺序被执行的，它有两个层面的乱序：
1）编译器层面的。因为编译器的优化往往会对代码的汇编指令进行重排。
2）CPU层面的。多 CPU 间存在内存乱序访问的情况。
内存屏障就是让编译器或CPU对内存的访问有序。

# pthread 库中的锁主要有以下几种类型：

‌互斥锁（Mutex）‌：
```
‌pthread_mutex_lock‌：这是最基本的互斥锁，当一个线程获取锁后，其他线程必须等待直到锁被释放。
‌pthread_mutex_trylock‌：尝试获取锁，如果锁已被占用，则立即返回，不会阻塞当前线程。
‌pthread_mutex_unlock‌：释放互斥锁，允许其他线程获取锁。
```
‌自旋锁（Spin Lock）‌：
```
‌pthread_spin_lock‌：尝试获取自旋锁，如果锁已被占用，线程会一直循环等待直到锁被释放。
‌pthread_spin_trylock‌：尝试获取自旋锁，如果锁已被占用，线程会立即返回而不是等待。
‌pthread_spin_unlock‌：释放自旋锁。
```
‌读写锁（Read/Write Lock）‌：
```
‌pthread_rwlock_rdlock‌：获取读锁，允许多个读操作同时进行。
‌pthread_rwlock_wrlock‌：获取写锁，写锁会阻塞其他读写操作。
‌pthread_rwlock_unlock‌：释放读写锁。
```
‌条件变量（Condition Variable）‌：
```
‌pthread_cond_wait‌：在条件变量上等待，直到另一个线程通知或超时。
‌pthread_cond_signal‌：通知在条件变量上等待的一个线程。
```

递归锁（互斥锁改造）

```
使用 PTHREAD_MUTEX_RECURSIVE 递归锁的一般步骤如下：
包含必要的头文件：#include <pthread.h>。
初始化互斥锁属性对象：使用 pthread_mutexattr_init(&attr); 初始化一个互斥锁属性对象 attr。
设置锁的类型为递归锁：通过 pthread_mutexattr_settype(&attr, pthread_mutex_recursive); 将互斥锁的类型设置为递归锁。
初始化递归锁：使用 pthread_mutex_init(&mutex, &attr); 初始化递归锁 mutex，并关联之前设置好属性的 attr 对象。
在需要加锁的代码段前加锁：通过 pthread_mutex_lock(&mutex); 进行加锁操作。如果是在同一个线程中且之前已经加过锁，不会产生死锁，而是可以成功再次加锁。
在相应的代码段结束后解锁：调用 pthread_mutex_unlock(&mutex); 释放锁。需要注意的是，加锁几次就需要解锁几次，才能完全释放该锁，以便其他线程获取该锁。
不再使用递归锁后，销毁互斥锁：使用 pthread_mutex_destroy(&mutex); 释放锁资源。
```