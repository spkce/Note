## 1.下载qt
qt官网：https://www.qt.io/，下载页面https://download.qt.io/选择5.9.0版本下载
qt-everywhere-opensource-src-5.9.0.tar.xz

注意：同时有.tar.xz和zip两个包，linux 使用qt-everywhere-opensource-src-5.9.0.tar.xz，不能在window文件系统中解压，一些软连接可能会损坏

## 2. 解压 
xz -d qt-everywhere-opensource-src-5.9.0.tar.xz
tar -xvf qt-everywhere-opensource-src-5.9.0.tar

## 3. 设定编译链
qtbase/mkspecs/linux-arm-gnueabi-g++/ 目录下更改文件qmake.conf

```
# modifications to g++.conf
QMAKE_CC                = /opt/gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux/bin/arm-linux-gnueabihf-gcc
QMAKE_CXX               = /opt/gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux/bin/arm-linux-gnueabihf-g++
QMAKE_LINK              = /opt/gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux/bin/arm-linux-gnueabihf-g++
QMAKE_LINK_SHLIB        = /opt/gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux/bin/arm-linux-gnueabihf-g++

# modifications to linux.conf
QMAKE_AR                = /opt/gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux/bin/arm-linux-gnueabihf-ar cqs
QMAKE_OBJCOPY           = /opt/gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux/bin/arm-linux-gnueabihf-objcopy
QMAKE_NM                = /opt/gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux/bin/arm-linux-gnueabihf-nm -P
QMAKE_STRIP             = /opt/gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux/bin/arm-linux-gnueabihf-strip
```

注意： bash的路径qt读取不到，所以需要用绝对路径

## 4. 产生makefile
```shell
./configure -prefix /opt/qt5.9.5-a7 -opensource -confirm-license -release -strip -shared -xplatform linux-arm-gnueabi-g++ -optimized-qmake -c++std c++11 -nomake examples -nomake tools -nomake tests -gui -widgets -dbus-runtime --glib=no --iconv=no --pcre=qt -no-openssl --freetype=qt --harfbuzz=qt -no-opengl -linuxfb --xcb=no --libpng=qt --libjpeg=qt --sqlite=qt
```

-prefix /opt/qt5.9.5-a7 是安装目录
-xplatform linux-arm-gnueabi-g++ 是平台，对应qtbase/mkspecs/目录下的文件夹

## 5. 编译
执行 make （可能需要sudo）


## 错误解决

Makefile:671: recipe for target '../../lib/libQt5Location.so.5.9.0' failed

修改文件vim qtlocation/src/location/maps/qgeotiledmapscene.cpp 
```
609 /*********
610                 if (ogl)
611                     static_cast<QSGDefaultImageNode *>(node)->setAnisotropyLevel(QSGTexture::Anisotropy16x);
612 **********/
613                 dirtyBits |= QSGNode::DirtyMaterial;
614             }
615             if (dirtyBits != 0)
616                 node->markDirty(dirtyBits);
617             it++;
618         }
619     }
620 
621     for (const QGeoTileSpec &s : toAdd) {
622         QGeoTileTexture *tileTexture = d->m_textures.value(s).data();
623         if (!tileTexture || tileTexture->image.isNull())
624             continue;
625         QSGImageNode *tileNode = window->createImageNode();
626         // note: setTexture will update coordinates so do it here, before we buildGeometry
627         tileNode->setTexture(textures.value(s));
628         if (d->buildGeometry(s, tileNode, overzooming)
629                 && qgeotiledmapscene_isTileInViewport(tileNode->rect(), root->matrix(), straight)) {
630             if (tileNode->texture()->textureSize().width() > d->m_tileSize * pixelRatio) {
631                 tileNode->setFiltering(QSGTexture::Linear); // with mipmapping QSGTexture::Nearest generates artifacts
632                 tileNode->setMipmapFiltering(QSGTexture::Linear);
633             } else {
634                 tileNode->setFiltering((d->m_linearScaling || overzooming) ? QSGTexture::Linear : QSGTexture::Nearest);
635             }
636 /**********
637             if (ogl)
638                 static_cast<QSGDefaultImageNode *>(tileNode)->setAnisotropyLevel(QSGTexture::Anisotropy16x);
639 **********/

```


## 6. 安装
执行 make install （可能需要sudo）
然后将 /opt目录下成果物拷贝到开发板的/opt下
### 环境变量设置
PC环境变量设置：
```shell
export PATH=$PATH:/opt/qt5.9.5-a7/bin
export QTEDIR=/opt/qt5.9.5-a7
export LD_LIBRARY_PATH=/opt/qt5.9.5-a7:$LD_LIBRARY_PATH
export QT_QPA_PLATFORM_PLUGIN_PATH=$QTEDIR/plugins
export QT_QPA_PLATFORM=linuxfb:fb=/dev/fb0:size=480x272:offset=0x0:tty=/dev/tty1
```
开发板环境变量设置：
```shell
export QTEDIR=/opt/qt5.9.5-a7
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/qt5.9.5-a7/lib
export QT_OPA_FONTDIR=$QTEDIR/lib/fonts
export QT_QPA_PLATFORM_PLUGIN_PATH=$QTEDIR/plugins
export QT_QPA_PLATFORM=linuxfb:fb=/dev/fb0:size=490x272:offset=0x0:tty=/dev/tty1
```
5.9.0可能没有字库 /opt/qt5.9.0/fonts/, 字库文件为qpf
## 测试程序

### 编译

测试程序代码 : helloQt.cpp
```c++
#include <QtWidgets/QApplication>
#include <QtWidgets/QLabel>

int main(int argc, char* argv[])
{
    QApplication a(argc, argv);
    QLabel *p = new QLabel("<h1>Hello qt!</h1>");
    p->show();

    return a.exec();
}
```
* 编译

`qmake -project `

`qmake helloQt.pro` 

此时生产Makefile 文件，打开再次Makefile确认CC 和 CXX 交叉编译工具链路径是否正确，

若调用过 `libQt5Widgets.so` 库中的东西，则Makefile的LIBS项需要添加-lQt5Widgets

`make`

最后将程序拷贝到开发板上运行


git clone http://code.qt.io/qt/qt5.git

git checkout 5.9.5 # 选择5.9.5版本

perl init-repository -f --module-subset=default #按需下载子模块

mkdir build

准备 sys_root .可以从系统中提取。 重要 若qt支持 xcb 、openGL、 openGLES等，需要在sys_root里面有相应的库和头文件。

配置选项：
../configure -prefix /opt/out -release -strip -shared   -xplatform linux-aarch64-gnu-g++  -opensource -confirm-license -sysroot /home/y0371/source/qt/fakeroot -c++std c++11 -xcb -qt-xcb -opengl es2 -egl -optimized-qmake -nomake examples -nomake tools -nomake tests -gui -widgets -qt-libjpeg -qt-libpng -qt-zlib --glib=no --iconv=no -no-reduce-relocations -no-dbus -no-libudev -skip qtconnectivity -skip qtlocation -skip qtmultimedia -skip qtwebengine -skip qt3d  -L $sys_root/usr/lib64/ -L $sys_root/usr/lib/ -I $sys_root/usr/include  


sys_root 中需要有EGL xcb GLES2等



编译完成后：
export MANPATH=QTEDIR/doc/man:MANPATH
export QTEDIR=/opt/out
export PATH=$PATH:$QTEDIR/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$QTEDIR/lib
export QT_OPA_FONTDIR=$QTEDIR/lib/fonts
export QT_QPA_PLATFORM_PLUGIN_PATH=$QTEDIR/plugins
export QMAKESPEC=$QTEDIR/mkspecs/linux-aarch64-gnu-g++

qt5版本已无fonts生成。字体需要下载或者从系统提取

将系统字体拷贝到qt安装目录下 cp /usr/share/fonts/truetype/dejavu/*.ttf  <xx>/lib/fonts

或者使用系统字体: ../configure -system-freetype -fontconfig。 需要有fontconfig和freetype2安装

# arm环境下编译5.9.5 （xcb）
../configure -prefix /opt/out -release -strip -shared   -xplatform linux-aarch64-gnu-g++ -system-freetype -fontconfig -opensource -confirm-license -sysroot <$sys_root> -c++std c++11 -xcb -qt-xcb -opengl es2 -egl -optimized-qmake -nomake examples -nomake tools -nomake tests -gui -widgets -qt-libjpeg -qt-libpng -qt-zlib --glib=no --iconv=no -no-reduce-relocations -no-dbus -no-libudev -skip qtconnectivity -skip qtlocation -skip qtmultimedia -skip qtwebengine -skip qt3d  -L <$sys_root>/usr/lib64/ -L <$sys_root>/usr/lib/ -I <$sys_root>/usr/include

在make install 阶段会有下面错误
```
/opt/qt-everywhere-opensource-src-5.9.5/qtserialbus/src/plugins/canbus/socketcan/socketcanbackend.cpp:667:41: error: 'SIOCGSTAMP' was not declared in this scope; did you mean 'SIOCSARP'?
  667 |         if (Q_UNLIKELY(ioctl(canSocket, SIOCGSTAMP, &timeStamp) < 0)) {
```

修改Qt源码‌在socketcanbackend.cpp中强制包含sockios.h并添加兼容性处理：
```
#include <sys/ioctl.h>
#include <linux/sockios.h>  // 显式声明SIOCGSTAMP:ml-citation{ref="6" data="citationList"}

// 若仍报错，添加备用定义
#ifndef SIOCGSTAMP
#define SIOCGSTAMP 0x8906
#endif
```
5.9.5 版本会识别不到 EGL on X11 xcbglintegrations组件不能编译出来

```
EGL on X11 ........................... no
```
qtbase/src/gui/configure.json中用于检查EGL的程序需要改，强转需要改为reinterpret_cast


其他 include 路径错误 
qttools/src/assistant/help/qhelpcontentwidget.cpp 
qttools/src/assistant/help/qhelpsearchengine.cpp 
qttools/src/assistant/help/qhelpsearchquerywidget.cpp 
qttools/src/assistant/help/qhelpsearchresultwidget.cpp 
qttools/src/designer/src/uitools/quiloader.cpp 
中需要#include "xxx.moc" 改为 #include ".moc/xxx.moc"


qmlplugindump可能会不出现
进入/opt/qt/qt5.9.5/build/qtdeclarative/tools目下手动编译
```
make sub-qmlplugindump-all
make sub-qmlplugindump-install_subtargets
```
## 更改显示路径
```
 ./qmake -v
QMake version 3.1
Using Qt version 5.9.5 in /opt/fakeroot/opt/out/lib
```
在qmake同级目录下增加qt.conf
指定路径
```
sudo sh -c 'echo -e "[Paths]\nPrefix = /opt/qt5.9.5" > qt.conf'
```
似乎路径不对也可以
```shell
sudo sh -c 'echo "[Paths]\nPrefix = /usr/local/qt5.9.5" > qt.conf'
root@rtk:/opt/qt5.9.5-arm64/bin# ./qmake -v
QMake version 3.1
Using Qt version 5.9.5 in /opt/qt5.9.5-arm64/bin/lib
```

[Paths]
Prefix=/opt/qt
Libraries=lib
Plugins=plugins

或者

[Paths]
Prefix= ..



# arm环境下编译6.7.3
```
../configure -prefix /opt/out -release -strip -shared   -xplatform linux-aarch64-gnu-g++  -system-freetype -fontconfig -opensource -confirm-license  -c++std c++11 -no-bundled-xcb-xinput -xcb -xcb-xlib -opengl es2 -egl -no-openssl -optimized-qmake -nomake examples -nomake tools -nomake tests -gui -widgets -qt-libjpeg -qt-libpng -qt-zlib --glib=no  -no-reduce-relocations -no-dbus -no-libudev -skip qtconnectivity -skip qtlocation  -skip qtwebengine -skip qt3d -L /usr/lib/aarch64-linux-gnu/ -I /usr/include/aarch64-linux-gnu/
```
依赖的库：
```
sudo apt install libx11-dev libx11-xcb-dev libxext-dev libxfixes-dev libxi-dev libxcb1 libxrender-dev libxcb1-dev libxcb-glx0-dev libxcb-keysyms1-dev libxcb-image0 libxcb-image0-dev libxcb-shm0 libxcb-shm0-dev libxcb-icccm4 libxcb-icccm4-dev libxcb-sync-dev libxcb-sync1 libxcb-xfixes0-dev libxcb-shape0-dev libxcb-randr0-dev libxcb-render-util0 libxcb-render-util0-dev libxcb-util-dev libxcb-xinerama0 libxcb-xinerama0-dev libxcb-xkb-dev libxkbcommon-dev libxkbcommon-x11-dev libdrm-dev libxcursor-dev libxcomposite-dev libxdamage-dev libxrandr-dev  libxdamage-dev libxcb-render0-dev libxcb-xinput-dev
 libxdamage-dev  libxcb-cursor-dev libxss-dev libxtst-dev
```
编译时可能需要指定pkgconfig。不然在configure阶段可能会找不到库
```
export PKG_CONFIG_PATH=/usr/lib/aarch64-linux-gnu/pkgconfig
```

#qt软键盘
https://download.qt.io/archive/qt/5.9/5.9.5/