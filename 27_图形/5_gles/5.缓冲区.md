# 常量顶点属性
```c++
//glVertexAttriblf 和 glVertexAttriblfv 加载 (x, 0.0, 0.0, 1.0)
void glVertexAttriblf(GLuint index, GLfloat x);
void glVertexAttriblfv(GLuint index, const GLfloat *values);
//glVertexAttrib2f 和 glVertexAttrib2fv 加载 (x, y, 0.0, 1.0)
void glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y);
void glVertexAttrib2fv(GLuint index, const GLfloat *values);
//glVertexAttrib3f 和 glVertexAttrib3fv 加载 (x, y, z, 1.0)
void glVertexAttrib3f( GLuint index, GLfloat x, GLfloat y, GLfloat z);
void glVertexAttrib3fv(GLuint index, const GLfloat *values);
//glVertexAttrib4f 和 glVertexAttribl4fv 加载 (x, y, z, w)
void glVertexAttrib4f( GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
void glVertexAttrib4fv(GLuint index, const GLfloat *values);
```

# 顶点属性数组

顶点属性数组对象就是存储在应用程序缓冲区的顶点数据,又分两种方式来分配和存储顶点属性数组：结构数组和数据结构,结构数组就是所有顶点数据使用一个数组来存储数据
```c++
glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized,  GLsizei stride, const void *ptr);
```
index:通用顶点属性索引
size：顶点数组中分量数量，有效值1-4
type：数据格式
stride：表示第i个分量到i+1分量间的位移
ptr：数据指针


例子：
```c++
GLfloat vertexPos[3 * 3] =
{
    0.0f,  0.5f, 0.0f, // v0
    -0.5f, -0.5f, 0.0f, // v1
    0.5f, -0.5f, 0.0f  // v2
};

glViewport ( 0, 0, esContext->width, esContext->height );

glClear ( GL_COLOR_BUFFER_BIT );

glUseProgram ( userData->programObject );

//使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）
glVertexAttribPointer ( 0, 3, GL_FLOAT, GL_FALSE, 0, vertexPos );
glEnableVertexAttribArray ( 0 );
```
# VBO
VBO(vertex Buffer Object)：顶点缓冲对象。在显卡存储空间中开辟一块区域，用于存放顶点的各类属性信息。如顶点坐标、纹理坐标、顶点颜色等数据。 在渲染时直接从显VBO去取数据而不必与CPU进行数据交换

### 如何使用VBO
1. 使用函数glGenBuffers和一个缓冲ID生成一个VBO对象：
```c++
unsigned int VBO;
glGenBuffers(1, &VBO);
```

2. 使用函数glBindBuffer绑定顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER. OpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。
```c++
glBindBuffer(GL_ARRAY_BUFFER, VBO); 
```
3. 使用函数glBufferData把定义好的顶点数据复制到缓冲的内存中
```c++
// vertices表示顶点数组
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
```
glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型，其中VBO代表是的GL_ARRAY_BUFFER。第二个参数指定传输数据的大小(以字节为单位)，用一个简单的sizeof计算出顶点数据大小就行。 第三个参数是我们希望发送的实际数据。第四个参数指定了我们希望显卡如何管理给定的数据，它有三种形式：
GL_STATIC_DRAW ：数据不会或几乎不会改变。
GL_DYNAMIC_DRAW：数据会被改变很多。
GL_STREAM_DRAW ：数据每次绘制时都会改变。

4. 用完后使用函数glDeleteBuffers删除缓冲区
glDeleteBuffers

# VAO
VAO(vertex Array Object)：顶点数组对象。
对于GPU来说VBO就是一堆数据，但是这堆数据怎么解析使用，需要glEnableVertexAttribArray等相关函数在每次绘制的时候告诉GPU，那么VAO的作用就是简化这个过程的，只需要在初始化的时候将这些解析逻辑与VAO绑定一次即可， 然后每次在绘制的时候只需绑定对应的VAO，而不必每次再绑定VBO，然后去告诉GPU如何解析相关数据了。
### 如何使用VAO

1. 首先调用函数glGenVertexArrays生成VAO
```c++
unsigned int VAO;
glGenVertexArrays(1, &VAO);
```
2. 调用函数glBindVertexArray绑定VAO
```c++
glBindVertexArray(VAO);
// 管理VBO，让VAO记住VBO的数据如何解析使用
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 3. 设置顶点属性指针
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
glBindVertexArray(0)
```
然后在绘制的时候使用函数glBindVertexArray(VAO)使用即可。

3. 退出时通过函数glDeleteVertexArrays删除VAO
glDeleteVertexArrays

# EBO
EBO：索引缓冲对象（Element Buffer Object）
假设需要绘制一个矩形（OpenGL主要处理三角形，矩形由两个三角形组成），这会生成下面的顶点的集合：
```c++
float vertices[] = {
    // 第一个三角形
    0.5f, 0.5f, 0.0f,   // 右上角
    0.5f, -0.5f, 0.0f,  // 右下角
    -0.5f, 0.5f, 0.0f,  // 左上角
    // 第二个三角形
    0.5f, -0.5f, 0.0f,  // 右下角
    -0.5f, -0.5f, 0.0f, // 左下角
    -0.5f, 0.5f, 0.0f   // 左上角
};
```
两个顶点叠加了，一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。使用索引缓冲对象（EBO）之后的顶点就为如下方式：
```c++
float vertices[] = {
    0.5f, 0.5f, 0.0f,   // 右上角
    0.5f, -0.5f, 0.0f,  // 右下角
    -0.5f, -0.5f, 0.0f, // 左下角
    -0.5f, 0.5f, 0.0f   // 左上角
};

unsigned int indices[] = { // 注意索引从0开始! 
    0, 1, 3, // 第一个三角形
    1, 2, 3  // 第二个三角形
};
```
### EBO的使用
```c++
unsigned int ebo;
unsigned int indices[] = {
        0, 1, 2, // 第一个三角形
        0, 2, 3  // 第二个三角形
};
//创建EBO
glGenBuffers(1, &ebo);
//绑定EBO
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
//设置EBO数据，EBO同VBO一样，也可以存放再VAO中
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

//绘制操作使用glDrawElements，而不是glDrawArrays
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
```