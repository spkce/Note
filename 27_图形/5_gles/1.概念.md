


# 渲染管线
顶点数据 → 三维变换 → 图元装配 → 剪裁剔除 → 光栅化 → 片元着色 → 混合与测试

## 顶点数据
规定顶点坐标、顶点颜色、顶点其他数据（法线、uv、切线）

## 三维变换
模型变换：使用矩阵数学工具使模型在空间中平移旋转缩放
视图变换：使用矩阵数学工具将顶点变换到相机坐标系
投影变换：使用矩阵数学工具将顶点坐标变换到屏幕坐标系

## 图元装配
一个三角形、一条直线等几何关系成为图元。图元装配经过三维变换后的顶点重新组成三角形、直线等过程。

## 剪裁剔除
剪裁：把视线为的图元裁掉、加快后续渲染效率
剔除：将背面朝向我们的图形提出

背面：若一个三角形A → B → C → A 顶点间顺时针为正面 。C → B → A → C 逆时针 为 背面 

## 光栅化
将顶点围成的区域的像素光栅计算出来，并没有决定颜色

## 片元着色
计算每个像素片元最终显示的颜色，每个像素都会单独计算一次

## 混合与测试
混合：决定透明效果
测试：确定像素前后关系，（叠加模型，要显示到同一个位置的像素）

# 纹理 Texture
纹理可以理解为图片. 在渲染图形时需要在其编码填充图片,为了使得场景更加逼真. ⽽这里使用的图片,就是常说的纹理.但是在 OpenGL ,我们更加习惯叫纹理,⽽不是图片.
纹理是一个用来保存图像颜色的元素值的缓存，渲染是指将数据生成图像的过程。纹理渲染则是将保存在内存中的颜色值等数据，生成图像的过程。

# 光栅化 Rasterization
将图像的位置和颜色信息转换成在屏幕上显示的位置和颜色的数据的过程。光栅化是 OpenGL 自动完成的，开发者无法影响。

# 片元着色器
⼀般⽤来处理图形中每个像素点颜色计算和填充; 通过光栅化产生的片元，需要通过片元着色器确定最终显示在屏幕上的每个像素点的颜色值和深度值。通常来说，片元的个数是远大于顶点的个数，所以它也是并行计算的。
 片元着色器是逐像素运算的程序，也就是说每个像素都会执行⼀次⽚段着⾊器，当然是并行的。

# 顶点着色器
处理图形每个顶点变换(旋转/平移/投影等)。
顶点着⾊器是逐顶点运算的程序，也就是说每个顶点数据都会执行一次顶点着⾊器，当然这是并⾏的，并且顶点着⾊器运算过程中⽆法访问其他顶点的数据
一般来说典型的需要计算的顶点属性主要包括顶点坐标变换、逐顶点光照 运算等等。顶点坐标由自身坐标系转换到归一化坐标系的运算，就是在这⾥发生的。顶点着色器的输出是片元着色器的输入

# 着⾊语言 GLSL
用于编写着色器程序的语言


# 坐标系
1. 屏幕坐标系
0 → x
↓
y

2. 纹理坐标系
y
↑
0 → x

3. 顶点坐标系
  y
  ↑
  0 → x
 /
 z

4. 图像坐标系
0 → x
↓
y

图像默认的原点在左上角，而 OpenGL ES 纹理读取数据或者 FBO 读取数据时都是以左下角开始，所以图像才会出现上下倒立的现象；

# 投影
由观察空间到裁剪空间在公式上左乘一个投影矩阵，投影矩阵的产生分为两种：正交投影和透视投影;
正投影就是没有3D效果的投影方式，用于显示2D效果；
透视投影就是有3D效果的投影方式，用于显示3D效果.


# 帧缓冲区
缓冲区就是显存，也被叫做帧缓存，它的作用是用来存储显卡芯片处理过或者即将提取的渲染数据。如同计算机的内存一样，显存是用来存储要处理的图形信息的部件。
混合测试后最终”存活”下来的像素需要被显示到屏幕上，但是显示屏幕之前，这些像素是会被先提交在帧缓冲区的。帧缓存区的每一存储单元对应屏幕上的一个像素，整个帧缓存区对应一帧图像。

在下一个刷新频率到来时，视频控制器会把帧缓冲区内的内容映射到屏幕上。一般采用双缓冲机制，存在两个帧缓冲区。

# 顶点数组对象 VAO
VAO (顶点数组对象：Vertex Array Object)是指顶点数组对象，主要用于管理 VBO 或 EBO ，减少 glBindBuffer 、glEnableVertexAttribArray、 glVertexAttribPointer 这些调用操作，高效地实现在顶点数组配置之间切换。

# 顶点缓冲区对象 VBO
VBO（顶点缓冲区对象:Vertex Buffer Object）是指把顶点数据保存在显存中，绘制时直接从显存中取数据，减少了数据传输的开销

# 像素缓冲区对象 PBO
PBO （Pixel Buffer Object）是 OpenGL ES 3.0 的概念(OpenGL 2.0 不支持 PBO ，3.0支持 PBO)，称为像素缓冲区对象，主要被用于异步像素传输操作。PBO 仅用于执行像素传输，不连接到纹理，且与 FBO （帧缓冲区对象）无关
1. PBO 类似于 VBO（顶点缓冲区对象），PBO 开辟的也是 GPU 缓存，而存储的是图像数据。
2. PBO 可以在 GPU 的缓存间快速传递像素数据，不影响 CPU 时钟周期，除此之外，PBO 还支持异步传输。
3. PBO 类似于“以空间换时间”策略，在使用一个 PBO 的情况下，性能无法有效地提升，通常需要多个 PBO 交替配合使用。

# 帧缓冲对象FBO
FBO(Frame Buffer Object) 即帧缓冲对象，通常使用 OpenGL ES 经过顶点着色器、片元着色器处理之后就通过使用 OpenGL ES 使用的窗口系统提供的帧缓冲区，这样绘制的结果是显示到窗口(屏幕)上。但是对于有些复杂的渲染处理，通过多个滤镜处理，这时中间流程的渲染采样的结果就不应该直接输出显示屏幕，而应该等所有处理完成之后再显示到窗口上。这个时候 FBO 就派上用场了
FBO 是一个容器，自身不能用于渲染，需要与一些可渲染的缓冲区绑定在一起，像纹理或者渲染缓冲区。，它仅且提供了 3 个附着（Attachment），分别是颜色附着、深度附着和模板附着。

# uniform 变量数据的缓冲区对象 UBO
UBO，Uniform Buffer Object 顾名思义，就是一个装载 uniform 变量数据的缓冲区对象，本质上跟 OpenGL ES 的其他缓冲区对象没有区别，创建方式也大致一致，都是显存上一块用于储存特定数据的区域。
当数据加载到 UBO ，那么这些数据将存储在 UBO 上，而不再交给着色器程序，所以它们不会占用着色器程序自身的 uniform 存储空间，UBO 是一种新的从内存到显存的数据传递方式，另外 UBO 一般需要与 uniform 块配合使用。

# 纹理缓冲区对象 TBO

TBO 需要配合缓冲区纹理（Buffer Texture）一起使用，Buffer Texture 是一种一维纹理，其存储数据来自纹理缓冲区对象（TBO），用于允许着色器访问由缓冲区对象管理的大型内存表。
在 GLSL 中，只能使用 texelFetch 函数访问缓冲区纹理，缓冲区纹理的采样器类型为 samplerBuffer 。
生成一个 TBO 的方式跟 VBO 类似，只需要绑定到 GL_TEXTURE_BUFFER ，而生成缓冲区纹理的方式与普通的 2D 纹理一样。
