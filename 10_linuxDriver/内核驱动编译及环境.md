# 内核环境
不下载内核源码，使用内核开发包
sudo apt install linux-headers-$(uname -r)
makefile 写为
```makefile
ARCH := arm64

# 指定交叉编译器前缀
CROSS_COMPILE := aarch64-linux-gnu-

# 指定内核源码路径
KDIR := /lib/modules/$(uname -r)/build

# 指定当前模块源码路径
PWD := $(shell pwd)

# 指定要编译的模块
obj-m += hello.o 

# 默认编译目标
default:
	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KDIR) M=$(PWD) modules

# 清理目标
clean:
	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KDIR) M=$(PWD) clean

# 安装模块
install:
	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KDIR) M=$(PWD) modules_install

.PHONY: default clean install
```

# 使用内核源码编译
## 将驱动放置内核目录中编译
1. 在内核源码的drivers目录中增加文件夹，且创建Kconifg、Makefile
```
mkdir linux-5.10.116/drivers/hello
touch linux-5.10.116/drivers/hello/Kconfig
touch linux-5.10.116/drivers/hello/Makefile
```
kconfig内容
```
config HELLO
tristate "hello driver"
help
  just a simplest driver.
default y
```
第一行内容 config HELLO ，在执行配置的时候，将会生成一个变量 CONFIG_HELLO ，而这个变量，将会在编译的时候，被 Makefile 引用。
最后一行的 default y ，就表示把 CONFIG_HELLO 的值设置成 y，从而让这个驱动被编译到内核中。

Makefile文件内容
```
obj-$(CONFIG_HELLO) += hello.o
```
2. 将hello/Kconfig登记在linux-5.10.116/drivers/Kconfig 文件的末尾
```
source "drivers/hello/Kconfig"

endmenu   // 加在这一句的上面
```

3.  将hello/Makefile登记在linux-5.10.116/drivers/Makefile 文件的末尾
```makefile
obj-$(CONFIG_HELLO)    += hello/
```

4. 在menuconfig中
Device Drivers -> hello driver 可以修改 驱动是编译进内核、独立、不编译

若选择编译进内核(y), 编译内核后则内核中会有该驱动，
```
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=./build -j32
```

若选择独立驱动(M)，编译驱动后会build/drivers/hello/有该驱动
```
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=./build -j32 modules
```


## 驱动指定内核目录编译

1. 内核编译
```
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=./build defconfig
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=./build menuconfig
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=./build -j32

```
2. 编译驱动
驱动的makefile中kdir需要指定到内核源码目录的build文件夹内
```
ARCH := arm64

# 指定交叉编译器前缀
CROSS_COMPILE := aarch64-linux-gnu-

# 指定内核源码路径
KDIR := /opt/linux-5.10.116/build

# 指定当前模块源码路径
PWD := $(shell pwd)

# 指定要编译的模块
obj-m += hello.o 

# 默认编译目标
default:
	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KDIR) M=$(PWD) modules

# 清理目标
clean:
	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KDIR) M=$(PWD) clean

# 安装模块
install:
	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KDIR) M=$(PWD) modules_install

.PHONY: default clean install
```

# 制作嵌入式Linux内核启动映像
用于为 ARM64 架构的 Linux 内核镜像添加 U-Boot 可识别的头信息
```
mkimage -A arm64 -C none -T kernel -a 0x43800000 -e 0x43800000 -n linux-5.10.116 -d ./build/arch/arm64/boot/Image ./build/arch/arm64/boot/xxx_uImage
//-A arm64：指定目标CPU架构为ARM64
//-C none：不对内核进行压缩
//-T kernel：指定映像类型为内核
//-a 0x43800000：设置内核在内存中的加载地址
//-e 0x43800000：设置内核运行的入口点地址（与加载地址相同）
//-n linux-5.10.116：指定映像名称为linux-5.10.116
//-d ./build/arch/arm64/boot/Image：指定源文件为编译生成的原始内核映像
//./build/arch/arm64/boot/xxx_uImage：输出的U-Boot格式内核映像文件路径
```
mkimage工具会在原始内核文件前添加64字节(0x40)的头部信息包含架构、操作系统类型、加载地址等关键参数.这样U-Boot引导程序才能正确识别和加载内核

# 错误

1. 使用git 管理内核源码时，内核的version magic 会改变导致驱动无法加载。
```
hello: version magic '5.10.116+ SMP mod_unload aarch64' should be '5.10.116 SMP mod_unload aarch64'
```
可以去掉.git重新编译内核环境及驱动


2. 若一个驱动由多个源文件编译，makefile需要这样写

```makefile
obj-m += platform_dev.o 
platform_dev-objes := platform_dev.o platform_drv.o
```