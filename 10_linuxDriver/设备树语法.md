
# 设备树语法
## 根节点
在每个.dsti和.dts中都会存在一个“/”根节点。
编译器DTC在对.dts进行编译生成dtb时，会对node进行合并操作，最终生成的dtb只有一个根节点

## 节点名
节点名命名标准为`node-name@unit-address`
node-name‌：描述设备类型或功能，如 codec、serial
unit-address‌：设备在总线上的地址，用于区分同一总线上的多个同类设备
例如：
```
serial@4270000 {
    reg = <0x4270000 0x1000>;
};
```
serial@4270000‌ 中的 4270000 是‌内存映射IO的寄存器基地址‌。这个串口设备的寄存器从内存地址 0x4270000 开始映射。
```
‌codec@18 {
    ......
}
```
‌codec@18 中的 18 通常是 I2C 总线上的‌设备地址‌。I2C 设备地址常用 7 位或 10 位表示，这里的 0x18 是该音频编解码器在 I2C 总线上的从机地址。

节点名钱可以加标签，主要用途是在其他地方引用
```
a_uart0 : serial@4270000 {
    reg = <0x4270000 0x1000>;
};
```
## compatible
`compatible = <manufacturer>,<model>` 
用于内核匹配驱动与硬件的核心标识, compatible可以有多个如果第一个字符串不匹配任何驱动程序，核心将使用第二个字符串继续进行匹配

## address-cells和size-cells
address-cells的值为1，它代表以此节点为parent的子节点中，reg属性中存在一个address值；size-cells的值为1，它代表以“\” 根节点为parent的子节点中，reg属性中存在一个size值。
即父节点的address-cells和size-cells决定了子节点的address和size的bit宽,(1cell = 32bit, 2cells = 64bit)
如下面例子，根节点的 address-cells 和 size-cells 为1，代表了下面serial节点reg有中address是32为，length是32位
```
/ {
    compatible = "acme,coyotes-revenge";
    #address-cells = <1>;
    #size-cells = <1>;
    interrupt-parent = <&intc>;

    serial@101f0000 {
        compatible = "arm,pl011";
        reg = <0x101f0000 0x1000 >;
        interrupts = < 1 0 >;
    };
    
```

## reg
reg的组织形式为`reg = <address1 length1 [address2 length2] [address3 length3] ... >`，
其中的每一组address length表明了设备使用的一个地址范围.
address为1个或多个cell，而length则为cell的列表或者为空（若#size-cells = 0）。这意味着子节点的 reg 值是一个单一的 uint32，这是一个不包含大小字段的地址
```
#address-cells = <1>;
 #size-cells = <1>;
 
    ...
 
    serial@101f0000 {
        compatible = "arm,pl011";
        reg = <0x101f0000 0x1000 >;
    };
 
    serial@101f2000 {
        compatible = "arm,pl011";
        reg = <0x101f2000 0x1000 >;
    };
 
    gpio@101f3000 {
        compatible = "arm,pl061";
        reg = <0x101f3000 0x1000
               0x101f4000 0x0010>;
    };

```
例子中为 GPIO 分配了两个地址范围：0x101f3000...0x101f3fff 和 0x101f4000..0x101f400f。

```
#address-cells = <2>;
#size-cells = <1>;
 
    ...
 
    gpio@101f3000 {
        compatible = "arm,pl061";
        reg =  <0x10000000 0x02000000 0x10000>;
    };

```
这种情况64位的地址就是高32位是0x10000000，低32位是0x02000000的64位地址所以他代表的地址空间就是：0x1000000002000000 + 0x10000的地址空间

## ranges
ranges是设备树中用于处理‌地址空间映射‌的关键属性
它定义了子节点地址空间与父节点地址空间之间的转换关系
ranges = <local_address parent_address address_size>
ranges 由 父节点 address-cells size-cells 和自身节点address-cells size-cells决定
例如：
```
#address-cells = <1>；
#size-cells = <1>；
weim {
    #address-cells = <2>；
    #size-cells = <1>；
    status = "okay";
    /* weim memory map: 32MB on CS0, 32MB on CS1, 32MB on CS2 */
    ranges = <0 0 0x08000000 0x02000000
              1 0 0x0a000000 0x02000000
              2 0 0x0c000000 0x02000000>;
......
```
local_address地址是2cells，parent_address地址是1cells，address_size是1cells

因此地址映射关系为:
```
(0x00000000 00000000 - 0x00000000 02000000] -> (0x08000000 0x0a000000]
(0x00000001 00000000 - 0x00000001 02000000] -> (0x0a000000 0x0c000000]
(0x00000002 00000000 - 0x00000002 02000000] -> (0x0c000000 0x0e000000]
```

## interrupt
#interrupt-cells：定义中断描述符的cell数量 通常是2或3
interrupt-parent： 指定中断控制器
interrupts 中断描述符
例如：
interrupts = < 2 0 >; 表示中断号2，0是指触发的方式(上升沿、下降沿等)

## status
控制设备的启用和禁用， 常用值
```
status = "okay";          // 设备启用（默认值）
status = "disabled";      // 设备存在但禁用
status = "fail";          // 设备存在但检测失败
status = "fail-sss";      // 因特定原因失败（sss为原因代码）
status = "reserved";      // 设备被保留（其他软件使用）
```

## 设备树的引用&
设备树中的&符号用于‌引用其他节点‌或属性。
例如：
```
&uart1 { status = "disabled"; };
```
表示修改名为uart1节点的status属性
```
interrupt-parent = <&intc>;
```
表示interrupt-parent属性指向intc节点的phandle ，在设备树中，‌phandle‌ 是一个32位的整数值，用于‌唯一标识一个节点‌，实现节点间的相互引。

## aliases
‌设备树中的aliases节点用于定义别名，方便内核或驱动通过简短名称访问设备节点
```
aliases {
    i2c0 = "/soc/i2c@12345678";
    spi1 = "/soc/spi@89abcdef";
};
```
可以通过&i2c0直接引用节点

# 编译
内核设备树编译命令
```
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- O=./build dtbs
```
选择的设备树若位于arch/arm64/boot/dts/<manufacturer>/下面，那么dtb文件就位于build/arch/arm64/boot/dts/<manufacturer>/下

dtc单独编译
```
dtc -I dts -O dtb -o b.dtb a.dts
```
a.dts是板级文件，它通过include引用soc级文件c.dtsi

# 反编译
a.dtb 反编译为b.dts
```
# 基本反编译（带注释 + 可读性最高）
dtc -I dtb -O dts -o b.dts a.dtb
# 带详细注释 + 保留所有属性顺序（最接近原始dts）
dtc -I dtb -O dts -o b.dts -f -H both a.dtb
```

## 设备树镜像
若设备树要烧写到独立分区，需要加uboot可识别的头信息
```
normal_mkimage -i a.dtb -n xxx --load 0x431FFF00 -o a.img
```

# 生成精简设备树
删除源文件中不需要的硬件节点，生成精简的设备树映像
```
./build/scripts/dtc/delnode ./build/arch/arm64/boot/dts/<manufacturer>/a.dtb ./build/arch/arm64/boot/dts/<manufacturer>/b.dtb
```
设备树的节点status属性设置为 "disabled"以及子节点会被删除


# 设备树数据结构
设备树在内核中的节点以`struct device_node`表示, `struct property`表示设备树节点下的属性
```c
struct device_node {
	const char *name; // 节点名字
	const char *type; // 节点类型
	phandle phandle;
	const char *full_name; // 节点全名
	struct fwnode_handle fwnode;

	struct	property *properties;
	struct	property *deadprops;	/* removed properties */
	struct	device_node *parent; // 父节点
	struct	device_node *child;  // 子节点
	struct	device_node *sibling; // 兄弟节点
	struct	kobject kobj;
	unsigned long _flags;
	void	*data;
#if defined(CONFIG_SPARC)
	const char *path_component_name;
	unsigned int unique_id;
	struct of_irq_controller *irq_trans;
#endif
};

struct property {
	char	*name;
	int	length;
	void	*value;
	struct property *next;
	unsigned long _flags;
	unsigned int unique_id;
	struct bin_attribute attr;
};
```
## OF api
驱动中读取设备树的api以of_开头
```c
/**
 * param - path: 从哪个节点开始向下查找
 * return: 失败返回NULL，成功返回找到的节点
 */
struct device_node *of_find_node_by_path(const char *path)
/**
from：起始搜索节点，若为NULL则从根节点开始搜索。
type：目标节点的device_type属性值，可为NULL（忽略类型限制）。
compat：目标节点的compatible属性名称。
 */
struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compat);

/**
 * param - np: 设备节点
 * param - name: 属性名
 * param - lenp: 输出型参数，表示属性值的字节数
 * return: 失败返回NULL，成功返回获取到的属性
 */
property *of_find_property(const struct device_node *np, const char *name, int *lenp)
/**
 * param - np: 设备节点
 * param - propname: 属性名
 * param - out_string: 输出型参数，表示读取到的字符串值 不分配新内存
 * return: 成功返回 0，失败返回负值
 */
int of_property_read_string(struct device_node *np, const char *propname, const char **out_string)

/**
 * param - np: 设备节点
 * param - propname: 属性名
 * param - out_string: 输出型参数，表示读取到的u32类型数组
 * param - sz: 输入型参数，表示要读取的数组元素数量
 * return: 成功返回 0，以下几种情况表示读取失败
           1、-EINVAL 表示属性不存在
           2、-ENODATA 表示没有要读取的数据
           3、-EOVERFLOW 表示属性值列表太小
 */
int of_property_read_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t sz)
//of_property_read_u8_array：读取属性中 u8 类型的数组数据
//of_property_read_u16_array：读取属性中 u16 类型的数组数据
//of_property_read_u32_array：读取属性中 u32 类型的数组数据
//of_property_read_u64_array：读取属性中 u64 类型的数组数据


int of_get_named_gpio(struct device_node *np, const char *list_name, int index);
unsigned int of_irq_get(struct device_node *np, int index);
int of_address_to_resource(struct device_node *dev, int index, struct resource *r); //仅仅可以读reg
```
例子：
```c
//获取reg属性
u32 regData[14];    // 数组的大小取决于 reg 中数据个数
int ret = of_property_read_u32_array(dtsNode, "reg", regData, 10);
if(ret < 0)
{
	printk("reg property read failed!\n");
	return -1;
}
//获取status属性
int ret = of_property_read_string(dtsNode, "status", &str);
if(ret < 0)
{
	printk("status property read failed!\n");
	return -1;
}
printk("status: %s\n", str);
//获取gpio
int gpio = of_get_named_gpio(np, "gpios", 0);
```

# 设备树与平台驱动
可以认为设备树代替了平台设备的角色，原本平台设备中关于硬件资源的代码被放在设备树对应设备节点的属性中声明了。
对于平台设备来说，reg和interrupt属性会被填到`struct platform_device` 中的`struct resource`中

设备匹配表 of_device_id
```c
static const struct of_device_id my_driver_of_match[] = {
    { .compatible = "vendor,my-device" },
    {}
};
// 2. 注册设备ID信息（供内核匹配使用）
MODULE_DEVICE_TABLE(of, my_driver_of_match);

static struct platform_driver test_driver = {
    .driver = {
        .name = DRIVER_NAME,
        .of_match_table = my_driver_of_match, //匹配表
        .owner = THIS_MODULE,
    },
    .probe = test_probe,
    .remove = test_remove,
};
// 3. 使用便利宏定义平台驱动结构并完成注册
module_platform_driver(my_driver);
```
.compatible 需要和设备树的节点的匹配
MODULE_DEVICE_TABLE 主要负责向内核‌注册设备的标识信息‌让内核知道这个驱动能支持哪些设备。主要是对于一些热拔插的驱动起作用。如usb插入后，自动加载对应的ko