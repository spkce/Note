### 1. const的作用是什么？ 与宏相比有什么差别？
1. 定义常量
2. 修饰函数参数
3. 修饰函数返回值
4. 修饰指针和引用

2 - 4 可以认为是 修饰变量 

差别  
* 类型检查方面:
const定义的常量是有类型的，编译器会进行类型检查。

* 作用域方面
const常量有明确的作用域规则，和普通变量一样
宏会在所有包含它的源文件中起作用，可能会导致命名冲突等问题

* 调试方面
const常量在调试时更友好。因为它是一个真正的变量（只是不能修改），在调试器中可以查看const常量的值、地址等信息。而宏在调试时只是简单的文本替换，调试器无法像对待变量一样处理宏，这使得在调试过程中，宏相关的问题可能更难定位。

* 内存分配方面
const常量可能会占用内存空间。对于全局的const常量或者静态的const常量，它们通常会在数据段分配内存（具体取决于编译器和优化设置）；对于局部的const常量，有些情况下编译器可能会将其优化为直接使用常量值而不分配内存，但也可能会分配内存。而宏只是在预处理阶段进行文本替换，本身不占用内存空间，因为它不是真正的变量。
### 2. final和override的作用
final:禁止继承该类或者覆盖该虚函数
override:必须覆盖基类的匹配的虚函数

使用场合（final）:

不希望这个类被继承，比如vector，编码者可能不够了解vector的实现，或者说编写者不希望别人去覆盖某个虚函数.顾名思义，final就是最终么
不希望这个函数再被其他子类覆写

使用场合（override）:

第一种情况是你想覆写一个基类的函数，但是不小心参数不匹配或者名字拼错，结果导致写了一个新的虚函数。这时候如果你加上override关键字，编译器会帮你发现与基类函数不匹配从而给出编译错误的提示。
第二种，在使用别人的函数库，或者继承了别人写的类时，你想写一个新函数，但是可能碰巧与原来基类的函数名称一样，这样就会被编译器（以及其他人）误认为要重写基类的函数。如果大家都养成习惯重写基类函数时都加上override，别人在看到你的代码时就知道你当前的函数是否想重写基类里面的函数，也就容易发现你这个无意中重载的Bug。

### 3. nullptr相比NULL会有什么优缺点
nullptr专门用于表示空指针，它的语义非常清晰，就是表示一个不指向任何有效对象的指针。在代码中看到nullptr，就能立刻明白这是在处理指针相关的情况，而NULL可能会因为它在 C 和 C++ 中的不同定义以及在不同上下文中的使用（如可以作为整数0）而产生混淆。
```c++
//下面这个函数重载使用NULL的话会出问题
void func(int);
void func(void*);
```
### 4. inline 和 宏函数的区别
* 语法检查方面
inline函数是真正的函数，它有完整的函数语法。编译器会对inline函数进行语法检查
* 作用域和生命周期方面
inline函数遵循普通函数的作用域和生命周期规则。并且受到访问控制（如public、private、protected等）的约束
* 语义方面
inline函数是一种函数调用机制的优化，它在语义上仍然是一个函数，有自己的参数传递、局部变量等概念。例如，inline函数可以有默认参数、可变参数等特性。而宏函数没有函数调用的语义，它只是代码的替换，不涉及参数传递的过程（虽然看起来像参数传递），也没有局部变量的概念。
* 调试方面
* 可维护性方面
### 5. 如何将一个成员函数保存成指针，让其他函数能正常调用。
1. 使用std::function和std::bind（C++11 及以上）
2. 对象指针 + 成员函数指针
### 6. c++ 虚函数重载原理
* 虚函数表（v - table）
虚函数表本质上是一个函数指针数组。对于包含n个虚函数的类，其虚函数表中有n个元素，每个元素都是一个函数指针，指向对应的虚函数。在单继承情况下，派生类会继承基类的虚函数表。如果派生类重写了基类的虚函数，那么在派生类的虚函数表中，对应的虚函数指针会指向派生类自己的重写函数。
* 动态绑定的实现过程
有Base* ptr = new Derived;，当执行ptr->func1();时，程序会首先获取ptr所指向对象的虚函数表指针（因为对象开头存储了这个指针），然后通过这个指针在虚函数表中查找func1对应的函数指针，最后调用这个函数指针所指向的函数（在这个例子中是Derived::func1）。
* 多个虚函数表和指针调整
在多继承情况下，派生类可能会有多个基类，每个基类都有自己的虚函数表。当一个派生类对象被创建时，它会包含多个虚函数表指针（每个基类一个），并且在进行函数调用时，需要根据对象的实际布局和函数所属的基类来正确地选择虚函数表进行查找。
例如，派生类Derived继承自Base1和Base2，如果Base1和Base2都有虚函数，Derived对象的内存布局会包含两个虚函数表指针，分别对应Base1和Base2的虚函数表。当通过Base1类型的指针调用虚函数时，会使用Base1对应的虚函数表进行查找；当通过Base2类型的指针调用虚函数时，会使用Base2对应的虚函数表进行查找。并且，在一些复杂的继承和函数调用场景下，编译器可能还需要进行指针调整操作，以确保正确地访问对象成员和虚函数。
### 7. 虚继承和非虚继承的区别？
主要用于解决多继承中可能出现的菱形继承问题。当一个类虚继承另一个类时，编译器会对继承关系进行特殊的处理，使得在菱形继承等复杂情况下，只有一份共享的基类对象被包含在最终的派生类对象中
### 8. 面向对象的几大设计原则
1. 单一职责原则（Single Responsibility Principle，SRP）
2. 开放 - 封闭原则（Open - Closed Principle，OCP）
3. 里氏替换原则（Liskov Substitution Principle，LSP）
4. 接口隔离原则（Interface Segregation Principle，ISP）
5. 依赖倒置原则（Dependency Inversion Principle，DIP）
### 9. 设计模式

### 10. c++11 中一个类有多少个默认函数

构造函数 A();
析构函数 ~A();
拷贝构造函数A(const A&);
赋值运算符重载A& operator(const A& );
移动构造函数A(const A&&);
移动赋值运算符重载A& operator(const A&& );