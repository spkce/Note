### 关键字registr，typdef的作用？
register关键字的作用：

请求CPU尽可能让变量的值保存在CPU内部的寄存器中，减去CPU从内存中抓取数据的时间，提高程序运行效率。

使用register关键字应注意什么？

1.只有局部变量才可以被声明用register修饰

（register不能修饰全局变量和函数的原因：全局变量可能被多个进程访问，而用register修饰的变量，只能被当前进程访问）

2.不能用取地址获取用register修饰的变量的地址（原因：变量保存在寄存器中，而取地址获取的地址的是内存的地址）

3. 用register修饰的变量一定要是CPU所接受的数据类型


### explicit关键字的作用？

C++中， 一个参数的 构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 1 是个 构造器 ，2 是个默认且隐含的类型转换操作符。
所以， 有时候在我们写下如 AAA = XXX， 这样的代码， 且恰好XXX的类型正好是AAA单参数构造器的参数类型， 这时候 编译器就自动调用这个构造器， 创建一个AAA的对象。
这样看起来好象很酷， 很方便。 但在某些情况下（见下面权威的例子）， 却违背了我们（程序员）的本意。 这时候就要在这个构造器前面加上explicit修饰， 指定这个构造器只能被明确的调用/使用， 不能作为类型转换操作符被隐含的使用。


### C++中指针和引用的区别

1）指针是一个新的变量，存储了另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；

引用只是一个别名，还是变量本身，对引用的任何操作就是对变量本身进行操作，以达到修改变量的目的

2）引用只有一级，而指针可以有多级

3）指针传参的时候，还是值传递，指针本身的值不可以修改，需要通过解引用才能对指向的对象进行操作

4 引用无默认初始化

引用传参的时候，传进来的就是变量本身，因此变量可以被修改




### C/C++面试题：i++与++i哪个效率更高？

考虑内建数据类型时，它们的效率差别不大（去除编译器优化的影响）。所以在这种情况下我们大可不必关心。
现在让我们再考虑自定义数据类型（主要是指类）的情况。此时我们不需要再做很多汇编代码的分析了，因为前缀式（++i）可以返回对象的引用，而后缀式（i++）必须返回对象的值，所以导致在大对象的时候产生了较大的复制开销，引起效率降低，因此处理使用者自定义类型（注意不是指内建类型）的时候，应该尽可能的使用前缀式地增/递减，因为他天生体质较佳。

答案：
内建数据类型的情况，效率没有区别。
自定义数据类型的情况，++i效率较高。

### C/C++类型转换
C语言直接用小括号进行类型转换

c++引入了下面四种类型转换：
1. static_cast
相当于c语言使用小括号转换，无类型检查

2. dynamic_cast
只能够用在指向类的指针或者引用上(或者void*)。这种转换的目的是确保目标指针类型所指向的是一个有效且完整的对象。这种转换允许upcast(从派生类向基类的转换)，downcast(从基类向派生类的转换)。转换失败指针返回空，引用抛出异常。会进行类型检查RTTI(Run-Time Type Identification)
```
dynamic_cast的工作过程
‌查找虚函数表‌：当通过dynamic_cast进行类型转换时，首先会查找对象的虚函数表。
‌运行时类型检查‌：利用RTTI检查目标类型是否与当前对象的实际类型兼容。
‌转换成功‌：如果转换成功，返回转换后的指针或引用；如果失败，返回空指针或抛出异常。
```
3. reinterpret_cast
reinterpret_cast能够完成任意指针类型向任意指针类型的转换（完全不相关的两个对象转化）。

4. const_cast
const_cast可以用来设置或者移除指针所指向对象的const


### C++类中的6个默认函数
1. 默认构造函数
2. 默认析构函数
3. 默认拷贝构造函数
4. 默认赋值运算符重载函数
5. 默认取址操作符重载函数
6. 默认const取址操作符重载函数

```c++
class CA
{
    CA(); // 默认构造函数
    ~CA(); // 默认析构函数
    CA(const CA &); // 默认拷贝构造函数
    CA & operator=(const CA&); //默认赋值运算符重载函数
    CA & operator&() const; //默认取地址操作符重载
    const CA & operator&() const; //默认const取址操作符重载
}
```

7. 默认移动构造函数 （c++11）
```c++
class CA
{
    CA(CA &&); // 默认移动构造函数
}；
```

### 构造和析构的顺序
下列程序成员函数的调用顺序：
```c++
class CB
{
public:
	CB();
	virtual ~CB();
};

class IA
{
public:
	IA();
	virtual ~IA();
};

class CA : public IA
{
public:
	CA();
	virtual ~CA();
	CB m_b;
};

int main()
{
    CB
    return 0;
}
```
IA() -> CB() -> CA() -> ~CA() -> ~CB() -> ~IA()


### 虚函数
1. 析构函数在什么时候下需要声明为虚函数

```c++
class IA
{
public:
	IA(){}
    ~IA()
	{
		printf("~IA()\n");
	};
};

class CA : public IA
{
public:
	CA() {};
	~CA() 
	{
		printf("~CA()\n");
	};

};

int main(int argc, char const *argv[])
{
	IA* p = new CA ;

	delete p; 
    //output:
    // ~IA()
	return 0;
}
```

```c++
class IA
{
public:
	IA(){}
	virtual ~IA()
	{
		printf("~IA()\n");
	};
};

class CA : public IA
{
public:
	CA() {};
	~CA() 
	{
		printf("~CA()\n");
	};

};

int main(int argc, char const *argv[])
	IA* p = new CA ;

	delete p; 
    //output:
    // ~CA()
    // ~IA()
	return 0;
}
```

# RTTI
C++ 的运行时类型信息 (RTTI) 是通过以下两个操作符实现的：
typeid：返回表达式的类型信息。std::type_info 对象
dynamic_cast：用于运行时检查对象的类型。

```
当使用typeid操作符时，编译器会根据表达式的静态类型生成相应的代码来获取其运行时类型信息。对于多态类型，typeid操作符通常会通过对象的虚函数表指针来获取其实际的类型信息。因为在多态情况下，对象的实际类型可能与它的静态类型不同，通过虚函数表指针可以追溯到对象的动态类型，从而获取到准确的类型信息
```